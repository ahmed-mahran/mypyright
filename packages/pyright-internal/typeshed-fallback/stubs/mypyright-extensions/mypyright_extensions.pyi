from abc import ABC
import ast
from types import ModuleType, NoneType
from typing import TYPE_CHECKING, Annotated, Any, Callable, Protocol, Self, Type

if TYPE_CHECKING:
  from typing import type_check_only

class _MyPyright(ABC):
  ...

@type_check_only
class Map[F, *Ts](_MyPyright):
  ...

class _SubscriptableFunctionSingle[T, **P, R](Protocol):
  def __call__(self, tp: Type[T], /, *args: P.args, **kwargs: P.kwargs) -> R: ...

class _SubscriptableFunctionVariadic[*Ts, **P, R](Protocol):
  def __call__(self, tp: Map[Type, *Ts], /, *args: P.args, **kwargs: P.kwargs) -> R: ...

class _SubscriptableMethodSingle[Owner, T, **P, R](Protocol):
  def __call__(self, instance: Owner, tp: Type[T], /, *args: P.args, **kwargs: P.kwargs) -> R: ...

class _SubscriptableMethodVariadic[Owner, *Ts, **P, R](Protocol):
  def __call__(self, instance: Owner, tp: Map[Type, *Ts], /, *args: P.args, **kwargs: P.kwargs) -> R: ...

class _SubscriptableClassMethodSingle[Owner, T, **P, R](Protocol):
  def __call__(self, owner: Type[Owner], tp: Type[T], /, *args: P.args, **kwargs: P.kwargs) -> R: ...

class _SubscriptableClassMethodVariadic[Owner, *Ts, **P, R](Protocol):
  def __call__(self, owner: Type[Owner], tp: Map[Type, *Ts], /, *args: P.args, **kwargs: P.kwargs) -> R: ...

class subscriptable[Owner, T, *Ts, **P, R]:
  def __init__(
      self,
      fn: (
        _SubscriptableFunctionVariadic[*Ts, P, R] |
        _SubscriptableFunctionSingle[T, P, R] |
        _SubscriptableMethodVariadic[Owner, *Ts, P, R] |
        _SubscriptableMethodSingle[Owner, T, P, R] |
        _SubscriptableClassMethodVariadic[Owner, *Ts, P, R] |
        _SubscriptableClassMethodSingle[Owner, T, P, R]
      )
  ) -> None: ...
  
  def __get__(self, instance: Owner | None, owner: Type[Owner]) -> Self: ...

  def __getitem__(self, tp: Map[Type, *Ts] | Type[T]) -> Callable[P, R]: ...
  
  def __call__(self, tp: Map[Type, *Ts] | Type[T], *args: P.args, **kwargs: P.kwargs) -> R: ...

class subscriptablefunction[T, *Ts, **P, R]:
  def __init__(self, fn: _SubscriptableFunctionVariadic[*Ts, P, R] | _SubscriptableFunctionSingle[T, P, R]) -> None: ...

  def __getitem__(self, tp: Map[Type, *Ts] | Type[T]) -> Callable[P, R]: ...

  def __call__(self, tp: Map[Type, *Ts] | Type[T], *args: P.args, **kwargs: P.kwargs) -> R: ...

class subscriptablemethod[Owner, T, *Ts, **P, R]:
  def __init__(self, fn: _SubscriptableMethodVariadic[Owner, *Ts, P, R] | _SubscriptableMethodSingle[Owner, T, P, R]) -> None: ...

  def __get__(self, instance: Owner, owner: Type[Owner]) -> Self: ...

  def __getitem__(self, tp: Map[Type, *Ts] | Type[T]) -> Callable[P, R]: ...

  def __call__(self, tp: Map[Type, *Ts] | Type[T], *args: P.args, **kwargs: P.kwargs) -> R: ...

class subscriptableclassmethod[Owner, T, *Ts, **P, R]:
  def __init__(self, fn: _SubscriptableClassMethodVariadic[Owner, *Ts, P, R] | _SubscriptableClassMethodSingle[Owner, T, P, R]) -> None: ...

  def __get__(self, instance: NoneType, owner: Type[Owner]) -> Self: ...

  def __getitem__(self, tp: Map[Type, *Ts] | Type[T]) -> Callable[P, R]: ...

  def __call__(self, tp: Map[Type, *Ts] | Type[T], *args: P.args, **kwargs: P.kwargs) -> R: ...

#################################################################################################
class TypeMap[*Params](ABC):
  @staticmethod
  def map_type(type_expr: str) -> str: ...

class ITypeRefinementStatus(ABC): ...

class TypeRefinementStatus(ABC):
  class _Ok(ITypeRefinementStatus): ...

  Ok: _Ok = ...

  class Undecidable(ITypeRefinementStatus):
    message: str
    def __init__(self, message: str) -> None: ...
    def __repr__(self) -> str: ...
    
  class Error(ITypeRefinementStatus):
    message: str
    def __init__(self, message: str) -> None: ...
    def __repr__(self) -> str: ...

  @staticmethod
  def is_ok(status: ITypeRefinementStatus | None) -> bool: ...


type TypeAST = ast.expr | ast.type_param


class RefinedType:
  def __init__(self, tp: TypeAST, attributes: dict[str, Any] | None = None, maps: dict[str, RefinedType] | None = None): ...
  @property
  def tp(self) -> TypeAST: ...
  @property
  def attributes(self) -> dict[str, Any]: ...
  def set_from(self, other: RefinedType) -> RefinedType: ...
  def get_attribute(self, key: str) -> Any | None: ...
  def set_attribute(self, key: str, value: Any) -> RefinedType: ...
  def update_attribute(self, key: str, update: Callable[[Any], Any], compute: Callable[[], Any]) -> RefinedType: ...
  def clone(self) -> RefinedType: ...
  def __repr__(self) -> str: ...


class TypeRefinementResult:
  refined_type: RefinedType
  status: ITypeRefinementStatus

  def __init__(self, refined_type: RefinedType, status: ITypeRefinementStatus): ...
  @staticmethod
  def is_ok(result: TypeRefinementResult | None) -> bool: ...
  @staticmethod
  def is_error(result: TypeRefinementResult | None) -> bool: ...
  @staticmethod
  def is_undecidable(result: TypeRefinementResult | None) -> bool: ...
  @property
  def tp_str(self) -> str: ...
  def __str__(self) -> str: ...

type RefinementFn[Result] = TypeAsFunction[TypeRefinementPredicate, Result]
type Refinement = RefinementFn[TypeRefinementResult]


class TypeRefinementPredicate[*Params]:
  @classmethod
  def init_type(cls, type_to_be_refined: RefinedType) -> RefinedType: ...

  @classmethod
  def refine_type(
    cls,
    type_to_be_refined: RefinedType,
    args: list[Refinement],
    assume: bool,
  ) -> TypeRefinementResult: ...

  @classmethod
  def type_repr(cls, args: list[TypeAsFunction[TypeRefinementPredicate, str]]) -> str: ...


class This(TypeRefinementPredicate): ...

class TypeAsFunction[T, Result]:
  def __init__(self, origin: ast.expr, base: type[T] | ast.expr, args: list[TypeAsFunction[T, Result]] | None = None, result: Result | None = None): ...
  @property
  def origin(self) -> ast.expr: ...
  @property
  def base(self) -> type[T] | ast.expr: ...
  @property
  def args(self) -> list[TypeAsFunction[T, Result]]: ...
  @property
  def result(self) -> Result | None: ...
  def __repr__(self) -> str: ...


def parse_str_dict(dict_expr: str) -> dict[str, str]: ...


class SymbolTable[T]:
  symbol_table: dict[str, str]
  reference_table: dict[str, type[T]]
  processed_files: set[str]
  module: ModuleType

  def __init__(self, symbol_table: str | dict[str, str], resolved: dict[str, type[T]] | None = None) -> None: ...
  def resolve_reference(self, reference: str) -> type[T] | None: ...

def resolve_types[T, Result](
    expr: ast.expr,
    symbol_table: SymbolTable[T],
    result_type: type[Result]
  ) -> TypeAsFunction[T, Result]: ...

def parse_type_expr(type_expr: str) -> ast.expr: ...

def assume[T, P: TypeRefinementPredicate](instance: T, predicate: type[P]) -> Annotated[T, P]: ...

def refine(
    tp: ast.expr,
    init_predicate: type[TypeRefinementPredicate] | None,
    tests: list[Refinement] | None,
    assumptions: list[Refinement] | None,
    typevar_bound_table: dict[str, Refinement | None],
    typevar_refinement_table: dict[str, Refinement],
) -> Refinement: ...
